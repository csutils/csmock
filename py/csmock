#!/usr/bin/env python

# Copyright (C) 2014 - 2021 Red Hat, Inc.
#
# This file is part of csmock.
#
# csmock is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# csmock is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with csmock.  If not, see <http://www.gnu.org/licenses/>.

# standard imports
import argparse
import copy
import importlib
import pkgutil
import os
import re
import shlex
import shutil
import subprocess
import sys
import time

# local imports
import csmock.common.util
from csmock.common.util         import shell_quote
from csmock.common.util         import strlist_to_shell_cmd
from csmock.common.results      import FatalError
from csmock.common.results      import ScanResults
from csmock.common.results      import transform_results


CSMOCK_DATADIR = "/usr/share/csmock"

CWE_MAP_FILE = CSMOCK_DATADIR + "/cwe-map.csv"

CSMOCK_SCRIPTS = CSMOCK_DATADIR + "/scripts"

CHROOT_FIXUPS = CSMOCK_SCRIPTS + "/chroot-fixups"

ENABLE_KEEP_GOING_SCRIPT = CSMOCK_SCRIPTS + "/enable-keep-going.sh"

PATCH_RAWBUILD = CSMOCK_SCRIPTS + "/patch-rawbuild.sh"

DEFAULT_KNOWN_FALSE_POSITIVES = CSMOCK_DATADIR + "/known-false-positives.js"

# original name of the file, which could have sounded offensive to people
DEFAULT_KNOWN_FALSE_POSITIVES_FALLBACK = CSMOCK_DATADIR + "/defect-blacklist.err"

# how long should we wait before checking mock profile availability again
MOCK_WAITING_TICK = 60

DEFAULT_CSWRAP_TIMEOUT = 30

DEFAULT_JOBS_CNT = 13

DEFAULT_RPM_OPTS = [
    "--define", "_without_testsuite 1",
    "--define", "apidocs 0",
    "--define", "libguestfs_runtests 0",
    "--define", "runselftest 0",
    "--define", "with_publican 0",
    "--without", "binfilter",
    "--without", "docs",
    "--without", "langpacks"]

RAWBUILD_RPM_OPTS = [
    "--define", "__patch " + PATCH_RAWBUILD,
    "--define", "_rawbuild -b _RAWBUILD",
    "--define", "nofips 1",
    "--define", "nopam 1",
    "--define", "norunuser 1",
    "--define", "noselinux 1",
    "--define", "_with_vanilla 1"]

DEFAULT_CSWRAP_FILTERS = [
    "csgrep --mode=json --quiet --path '^/builddir/build/BUILD/' --remove-duplicates"]

# remember to use --mode=json for csgrep (TODO: improve csgrep's interface)
DEFAULT_RESULT_FILTERS = [
    "csgrep --mode=json --path '^/builddir/build/BUILD/' \
--strip-path-prefix /builddir/build/BUILD/",
    "csgrep --mode=json --invert-match --path '^ksh-.*[0-9]+\\.c$'",
    "csgrep --mode=json --invert-match --path 'CMakeFiles/CMakeTmp|conftest.c'"]

# path to csexec-loader is hard-coded for now
CSEXEC_ENABLE_FLAG = "-Wl,--dynamic-linker,/usr/bin/csexec-loader"


def find_missing_pkgs(pkgs, results, mock):
    # dump list of RPMs installed in the chroot (for debugging purposes)
    cmd = strlist_to_shell_cmd(mock.get_mock_cmd(["--shell", "rpm -qa"]))
    cmd += " | sort -V > %s/rpm-list-mock.txt" % results.dbgdir
    if results.exec_cmd(cmd, shell=True) != 0:
        results.error("failed to get list of packages installed in chroot")

    # get full list of provides
    provides = "%s/rpm-list-mock-provides.txt" % results.tmpdir
    cmd = strlist_to_shell_cmd(mock.get_mock_cmd(["--shell", "rpm -qa --provides"]))
    cmd += " | sort -V > %s" % provides
    if results.exec_cmd(cmd, shell=True) != 0:
        results.error("failed to get list of RPM provides in chroot")

    missing = []
    installed = set()
    with open(provides) as f:
        lines = f.readlines()
        for l in lines:
            pkg = re.sub(" .*$", "", l.strip())
            installed.add(pkg)

    for dep in pkgs:
        pkg = re.sub(" .*$", "", dep)
        if pkg in installed:
            continue
        missing += [dep]

    return missing


class MockWrapper:
    def __init__(self, results, props):
        self.results = results
        self.mock_profile = props.mock_profile
        self.lock_file = "/tmp/.csmock-%s.lock" % self.mock_profile
        self.meta_lock_file = "/tmp/.csmock-%s.metalock" % self.mock_profile
        self.pid = os.getpid()
        self.scrub_done = props.skip_mock_init
        self.init_done = props.skip_mock_init
        self.skip_clean = props.skip_mock_clean
        self.use_login_shell = props.use_login_shell
        # just to silence pylint, will be initialized in __enter__()
        self.def_cmd = None

    def __enter__(self):
        cmd = "flock -w%u '%s' -c '\
lock_file=\"%s\" \n\
self_pid=\"%d\" \n\
if test -e \"$lock_file\"; then \n\
    test -e /proc/\"$self_pid\"     || exit $? \n\
    read pid < \"$lock_file\"       || exit $? \n\
    test ! -e /proc/\"$pid\"        || exit $? \n\
    echo \"warning: purging stray lock file $lock_file (PID $pid)\" >&2 \n\
fi \n\
echo \"$self_pid\" > \"$lock_file\"'" \
            % (MOCK_WAITING_TICK, self.meta_lock_file, self.lock_file, self.pid)
        while os.system(cmd) != 0:
            f = open(self.lock_file)
            other_pid = ""
            if f is not None:
                other_pid = f.readline().rstrip()
                f.close()
            msg = "waiting till %s (PID %s) disappears..."
            self.results.print_with_ts(msg % (self.lock_file, other_pid))
            time.sleep(MOCK_WAITING_TICK)

        # prepare the mock command template with default arguments
        if os.path.exists("/usr/bin/mock-unbuffered"):
            # mock wrapper writing debug output without buffering
            mock = "/usr/bin/mock-unbuffered"
        elif os.path.exists("/usr/bin/mock"):
            # mock wrapper for non-privileged users (members of group mock)
            mock = "/usr/bin/mock"
        else:
            # fallback to any mock in $PATH (e.g. /usr/local/bin/mock)
            mock = "mock"
        self.def_cmd = [mock, "-r", self.mock_profile]

        # make csmock work in case the 'tmpfs' plug-in is enabled
        # (see <https://bugzilla.redhat.com/1190100> for details)
        self.def_cmd += ["--plugin-option=tmpfs:keep_mounted=True"]

        # re-enable verbose output per https://bugzilla.redhat.com/1166609
        self.def_cmd += ["--config-opts=print_main_output=True"]

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if not self.skip_clean:
            # clean up mock chroot
            if self.exec_mock_cmd(["--clean"]) != 0:
                self.results.error("failed to clean mock chroot: %s" % self.mock_profile, ec=0)

        # release the lock file
        cmd = "test -r '%s' && test %d = \"$(<%s)\" && rm -f '%s'" % (
            self.lock_file, self.pid, self.lock_file, self.lock_file)
        os.system(cmd)

    def get_mock_cmd(self, args, quiet=True):
        cmd = self.def_cmd.copy()
        if quiet:
            cmd += ["--quiet"]
        return cmd + args

    def exec_mock_cmd(self, args, quiet=True):
        cmd = self.get_mock_cmd(args, quiet=quiet)
        return self.results.exec_cmd(cmd)

    def exec_chroot_cmd(self, cmd, quiet=True):
        return self.exec_mock_cmd(["--chroot", cmd], quiet=quiet)

    def exec_mockbuild_cmd(self, cmd, quiet=True):
        args = ""
        if self.use_login_shell:
            args = " -l"
        full_cmd = "/bin/su mockbuild%s -c %s" % (args, shell_quote(cmd))
        return self.exec_chroot_cmd(full_cmd, quiet=quiet)

    def copy_out(self, args, quiet=True):
        cmd = ["--disable-plugin=selinux", "--copyout"] + args
        return self.exec_mock_cmd(cmd, quiet=quiet)

    def try_install(self, pkgs, quiet=True):
        return (self.exec_mock_cmd(["--install"] + pkgs, quiet=quiet) == 0)

    def install_deps(self, srpm, quiet=True):
        return (self.exec_mock_cmd(["--installdeps", srpm], quiet=quiet) == 0)

    def emergency_install_deps(self, srpm):
        (_, raw_deps) = self.results.get_cmd_output("rpm -qp '%s' --requires" % srpm)
        for dep in raw_deps.split("\n"):
            if (dep):
                self.try_install([dep])

    def remove(self, pkgs):
        return (self.exec_mock_cmd(["--remove"] + pkgs) == 0)

    def copy_in_resolv_conf(self):
        resconf = "/etc/resolv.conf"
        return (self.exec_mock_cmd(["--copyin", resconf, resconf]) == 0)

    def init_and_install(self, srpm, pkgs=[], force_scrub=False, keep_going=False):
        if force_scrub:
            scrub_root_passes = [True]
            # yet another hack for libguestfs/supermin
            self.exec_mock_cmd(["--scrub=dnf-cache"], quiet=False)
        else:
            scrub_root_passes = [False, True]

        for scrub_root in scrub_root_passes:
            if scrub_root and not self.scrub_done:
                self.exec_mock_cmd(["--scrub=root-cache"], quiet=False)
                self.scrub_done = True
                self.init_done = False

            # run `mock --init` if not disabled
            if not self.init_done and (self.exec_mock_cmd(["--init"], quiet=False) != 0):
                if scrub_root:
                    self.results.fatal_error("failed to init mock profile (%s)" % self.mock_profile)
                else:
                    self.results.error("failed to init mock profile (%s), trying to scrub cache..." \
                            % self.mock_profile, ec=0)
                    continue
            self.init_done = True

            # run `mock --installdeps`
            srpm_deps_ok = self.install_deps(srpm)
            if not srpm_deps_ok:
                srpm_base = os.path.basename(srpm)
                if self.scrub_done:
                    self.results.error("failed to install build dependencies of %s" % srpm_base)
                else:
                    self.results.error("failed to install build dependencies of %s, trying to scrub cache..." \
                            % srpm_base, ec=0)
                    continue

                if keep_going:
                    self.emergency_install_deps(srpm)

            if not pkgs:
                return srpm_deps_ok

            # run `mock --install`
            self.try_install(pkgs)
            missing_deps = find_missing_pkgs(pkgs, self.results, self)
            if not missing_deps:
                # no misssing dependencies
                return srpm_deps_ok

            if self.scrub_done:
                self.results.error("failed to install required packages (%s)" % strlist_to_shell_cmd(missing_deps))
                return False
            else:
                self.results.error("failed to install required packages (%s), trying to scrub cache..." \
                        % strlist_to_shell_cmd(missing_deps), ec=0)
                continue

        return False


class ScanProps:
    def __init__(self):
        self.plugins = None
        self.install_pkgs = []
        self.install_pkgs_blacklist = []
        self.install_opt_pkgs = []
        self.copy_in_files = [CSMOCK_SCRIPTS]
        self.pre_mock_hooks = []
        self.post_depinst_hooks = []
        self.rpm_opts = DEFAULT_RPM_OPTS
        self.path = []
        self.env = {}
        self.copy_out_files = []
        self.csexec_enabled = False
        self.cswrap_enabled = False
        self.cswrap_filters = DEFAULT_CSWRAP_FILTERS
        self.result_filters = DEFAULT_RESULT_FILTERS
        self.build_cmd_wrappers = []
        self.post_build_chroot_cmds = []
        self.post_process_hooks = []
        self.keep_going = False
        self.cswrap_timeout = DEFAULT_CSWRAP_TIMEOUT
        self.no_scan = False
        self.print_defects = False
        self.need_rpm_bi = False
        self.run_check = False
        self.use_login_shell = True
        self.skip_mock_init = False
        self.skip_mock_clean = False
        self.shell_cmd_to_build = None
        self.srpm = None
        self.base_srpm = None
        self.mock_profile = None
        self.base_mock_profile = None
        self.any_tool = False
        self.nvr = None
        self.imp_checker_set = set()
        self.imp_csgrep_filters = []

    def enable_cswrap(self):
        if self.cswrap_enabled:
            # already enabled
            return
        self.cswrap_enabled = True

        # resolve cswrap_path by querying cswrap binary
        cmd = ["cswrap", "--print-path-to-wrap"]
        subproc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, _) = subproc.communicate()
        cswrap_path = out.decode("utf8").strip()

        self.copy_in_files += ["/usr/bin/cswrap", cswrap_path]
        self.path = [cswrap_path] + self.path
        self.env["CSWRAP_CAP_FILE"] = "/builddir/cswrap-capture.err"
        self.env["CSWRAP_TIMEOUT"] = "%d" % self.cswrap_timeout
        self.env["CSWRAP_TIMEOUT_FOR"] = ":"
        self.copy_out_files += ["/builddir/cswrap-capture.err"]

    def enable_csexec(self):
        if self.csexec_enabled:
            # already enabled
            return
        self.csexec_enabled = True

        # copy statically linked csexec binaries into chroot
        self.copy_in_files += [
                "/usr/bin/csexec",
                "/usr/bin/csexec-loader",
                "/usr/lib64/libcsexec-preload.so"]

        # use the "gcc" plug-in to inject linker flags
        gcc = self.plugins["gcc"]
        gcc.enable()
        # FIXME: This only works if Plugin::handle_args() of gcc.py has not yet been called
        gcc.flags.append_flags([CSEXEC_ENABLE_FLAG])

    def pick_cswrap_results(self, results):
        if not self.cswrap_enabled:
            # not enabled --> succeeded trivially
            return 0

        # apply all filters using a shell pipe
        fin = "%s/builddir/cswrap-capture.err" % results.dbgdir_raw
        out = "%s/cswrap-capture.js" % results.dbgdir_uni
        cmd = "cat '%s'" % fin
        for filt in self.cswrap_filters:
            cmd += " | %s" % filt
        cmd += " > '%s'" % out
        (rv, _) = results.get_cmd_output(cmd)
        return rv

    def wrap_build_cmd(self, cmd_in):
        cmd_out = cmd_in
        for w in self.build_cmd_wrappers:
            cmd_out = "sh -c %s" % shell_quote(cmd_out)
            cmd_out = w % cmd_out
        return cmd_out

    def wrap_shell_cmd_by_env(self, cmd_in):
        # serialize self.path
        path_str = ""
        for p in self.path:
            path_str += p + ":"
        cmd_out = "PATH=%s$PATH " % path_str

        # serialize self.env
        assert "PATH" not in self.env
        for var in self.env:
            cmd_out += "%s=$'%s' " % (var, self.env[var])

        # run a new instance of shell for the specified command
        cmd_out += "sh -c %s" % shell_quote(cmd_in)
        return cmd_out


class PluginManager:
    def __init__(self):
        self.plug_by_prio = {}
        self.plug_by_name = {}

    def try_load(self, mod_name):
        full_name = "csmock.plugins." + mod_name
        mod = importlib.import_module(full_name)
        plugin = mod.Plugin()

        props = plugin.get_props()
        # TODO: check API version
        prio = props.pass_priority
        assert prio not in self.plug_by_prio
        self.plug_by_prio[prio] = plugin
        self.plug_by_name[mod_name] = plugin

    def load_default_plugins(self):
        pkg = importlib.import_module("csmock.plugins")
        for (_, mod_name, _) in pkgutil.iter_modules(pkg.__path__):
            self.try_load(mod_name)

    # Print description of each available plugin in format TOOL [:indent:] DESCRIPTION
    def print_plugin_descriptions(self):
        max_key_len = max(map(len, self.plug_by_name.keys()))
        min_indent_len = 8
        description_indent = max_key_len + min_indent_len
        for key, plugin in sorted(self.plug_by_name.items()):
            desc = getattr(plugin.get_props(), "description", "")
            sys.stdout.write("{}{}{}\n".format(
                key, " " * (description_indent - len(key)),
                desc.replace('\n', '\n%s' % (" " * description_indent))))

    def get_name_list(self):
        return sorted(self.plug_by_name.keys())

    def enable(self, plugin_name):
        plugin = self.plug_by_name[plugin_name]
        plugin.enable()

    def enable_all(self):
        for prio in sorted(self.plug_by_prio):
            plugin = self.plug_by_prio[prio]
            experimental= getattr(plugin.get_props(), "experimental", False)
            if experimental:
                continue
            plugin.enable()

    def init_parser(self, parser):
        for prio in sorted(self.plug_by_prio):
            plugin = self.plug_by_prio[prio]
            plugin.init_parser(parser)

    def handle_args(self, parser, args, props):
        for prio in sorted(self.plug_by_prio):
            plugin = self.plug_by_prio[prio]
            plugin.handle_args(parser, args, props)

    def num_enabled(self):
        cnt = 0
        for prio in sorted(self.plug_by_prio):
            plugin = self.plug_by_prio[prio]
            if getattr(plugin, "enabled", False):
                cnt = cnt + 1
        return cnt


def re_from_checker_set(checker_set):
    """return operand for the --checker option of csgrep based on checker_set"""
    chk_re = "^("
    first = True
    for chk in checker_set:
        if first:
            first = False
        else:
            chk_re += "|"
        chk_re += chk
    chk_re += ")$"
    return chk_re


# transform scan-results.js to scan-results.{err,html} and write stats
def finalize_results(js_file, results, props):
    if props.imp_checker_set:
        # filter out "important" defects, first based on checkers only
        cmd = "csgrep '%s' --mode=json --checker '%s'" % \
                (js_file, re_from_checker_set(props.imp_checker_set))

        # then apply custom per-checker filters
        for (chk, csgrep_args) in props.imp_csgrep_filters:
            chk_re = re_from_checker_set(props.imp_checker_set - set([chk]))
            cmd += " | csdiff <(csgrep '%s' --mode=grep --invert-regex --checker '%s' %s) -" \
                    % (js_file, chk_re, csgrep_args)

        # write the result into *-imp.js
        imp_js_file = re.sub("\\.js", "-imp.js", js_file)
        cmd += " > '%s'" % imp_js_file

        # bash is needed to process <(...)
        cmd = strlist_to_shell_cmd(["bash", "-c", cmd], escape_special=True)
        results.exec_cmd(cmd, shell=True)

        # generate *-imp.{err,html}
        transform_results(imp_js_file, results)

        # initialize the "imp" flag in the resulting full .js output file
        tmp_js_file = re.sub("\\.js", "-tmp.js", js_file)
        cmd = "cslinker --implist '%s' '%s' > '%s' && mv -v '%s' '%s'" \
                % (imp_js_file, js_file, tmp_js_file, tmp_js_file, js_file)
        results.exec_cmd(cmd, shell=True)

    (err_file, _) = transform_results(js_file, results)

    if props.print_defects:
        os.system("csgrep '%s'" % err_file)


# argparse._VersionAction would write to stderr, which breaks help2man
class VersionPrinter(argparse.Action):
    def __init__(self, option_strings, dest=None, default=None, help=None):
        super(VersionPrinter, self).__init__(
            option_strings=option_strings, dest=dest, default=default, nargs=0,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        print("@VERSION@")
        sys.exit(0)


# provide a more user-friendly error message in case a plug-in is not installed
class FileNameParser(argparse.Action):
    def __call__(self, parser, namespace, val, os=None):
        if isinstance(val, str) and val.startswith("--"):
            parser.error("File name '%s' starts with '--', which looks like \
option.  Are you sure, you have necessary plug-ins installed?  If it really \
is a file name, please use the './' prefix." % val)
        else:
            setattr(namespace, self.dest, val)


def require_file(parser, name):
    """Print an error and exit unsuccessfully if 'name' is not a file"""
    if not os.path.isfile(name):
        parser.error("'%s' is not a file" % name)


def main():
    # load plug-ins
    plugins = PluginManager()
    plugins.load_default_plugins()
    plugin_list = plugins.get_name_list()

    # list available tools
    # FIXME: --list-available-tools takes precedence over --help and --version
    class ToolsPrinter(argparse.Action):
        def __init__(self, option_strings, dest=None, default=None, help=None):
            super(ToolsPrinter, self).__init__(
                option_strings=option_strings, dest=dest, default=default, nargs=0,
                help=help)

        def __call__(self, parser, namespace, values, option_string=None):
            sys.stdout.write('Tools list: \n')
            plugins.print_plugin_descriptions()
            sys.exit(0)

    # initialize argument parser
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "SRPM", nargs="?", action=FileNameParser,
        help="source RPM package to be scanned by static analyzers")

    # define optional arguments
    parser.add_argument(
        "-r", "--root", dest="mock_profile", default="default",
        help="mock profile to use (defaults to mock's default)")

    parser.add_argument(
        "-t", "--tools", action="append", default=[],
        help="comma-spearated list of tools to enable \
(use --list-available-tools to see the list of available tools)")

    parser.add_argument(
        "-a", "--all-tools", action="store_true",
        help="enable all available tools \
(use --list-available-tools to see the list of available tools)")

    parser.add_argument(
        "-l", "--list-available-tools", action=ToolsPrinter,
        help="list available tools and exit")

    parser.add_argument(
        "--install", action="append", default=[],
        help="space-separated list of packages to install into the chroot")

    parser.add_argument(
        "-o", "--output",
        help="name of the tarball or directory to put the results to")

    parser.add_argument(
        "-f", "--force", action="store_true",
        help="overwrite the resulting file or directory if it exists already")

    parser.add_argument(
        "-j", "--jobs", type=int, default=DEFAULT_JOBS_CNT,
        help="maximal number of jobs running in parallel (passed to 'make')")

    parser.add_argument(
        "--rpm-build-opts", action="append", default=[],
        help="shell-quoted options passed to rpm-build")

    parser.add_argument(
        "--cswrap-timeout", type=int, default=DEFAULT_CSWRAP_TIMEOUT,
        help="maximal amount of time taken by analysis of a single module [s]")

    parser.add_argument(
        "-U", "--embed-context", type=int, default=3,
        help="embed a number of lines of context from the source file for the \
key event (defaults to 3).")

    parser.add_argument(
        "-k", "--keep-going", action="store_true",
        help="continue as much as possible after an error")

    parser.add_argument(
        "--skip-init", action="store_true",
        help="do not run 'mock --init' before the scan \
(may lead to unpredictable scan results)")

    parser.add_argument(
        "--no-clean", action="store_true",
        help="do not clean chroot when it becomes unused")

    parser.add_argument(
        "--no-scan", action="store_true",
        help="do not analyze any package, just check versions of the analyzers")

    csmock.common.util.add_paired_flag(
        parser, "run-check",
        help="run the %%check section of specfile (disabled by default)")

    csmock.common.util.add_paired_flag(
        parser, "print-defects",
        help="print the resulting list of defects (default if connected to a tty)")

    parser.add_argument(
        "--base-srpm",
        help="perform a differential scan against the specified base pacakge")

    parser.add_argument(
        "--base-root", dest="base_mock_profile",
        help="mock profile to use for the base scan (use only with --base-srpm)")

    # --skip-patches, --diff-patches, and --shell-cmd are mutually exclusive
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--skip-patches", action="store_true",
        help="skip patches not annotated by %%{?_rawbuild} (vanilla build)")
    group.add_argument(
        "--diff-patches", action="store_true",
        help="scan with/without patches and diff the lists of defects")
    group.add_argument(
        "-c", "--shell-cmd",
        help="use shell command to build the given tarball (instead of SRPM)")

    # --known-false-positives
    if os.path.exists(DEFAULT_KNOWN_FALSE_POSITIVES):
        default_kfp = DEFAULT_KNOWN_FALSE_POSITIVES
        default_kfp_text = " (defaults to \"%s\")" % default_kfp
    elif os.path.exists(DEFAULT_KNOWN_FALSE_POSITIVES_FALLBACK):
        default_kfp = DEFAULT_KNOWN_FALSE_POSITIVES_FALLBACK
        default_kfp_text = " (defaults to \"%s\")" % default_kfp
    else:
        default_kfp = ""
        default_kfp_text = " (defaults to \"%s\" if available)" % DEFAULT_KNOWN_FALSE_POSITIVES
    parser.add_argument(
        "--known-false-positives", default=default_kfp,
        help=("suppress known false positives loaded from the given file" + default_kfp_text))

    csmock.common.util.add_paired_flag(
        parser, "use-login-shell",
        help="use login shell for build (default)")

    # needed for help2man
    parser.add_argument(
        "--version", action=VersionPrinter,
        help="print the version of csmock and exit")

    # add command-line options handled by plugins
    plugins.init_parser(parser)

    # parse command-line arguments
    args = parser.parse_args()

    if args.print_defects is None:
        args.print_defects = sys.stdout.isatty()

    # check that only available tools are requested (and enable them)
    for i in args.tools:
        for j in i.split(","):
            tool = j.strip()
            if not tool:
                continue
            if tool in plugin_list:
                # explicitly enable this tool
                plugins.enable(tool)
            else:
                parser.error("tool not available: %s" % tool)

    if args.all_tools:
        # enable all available tools
        plugins.enable_all()

    output = args.output
    if args.SRPM is None:
        if args.no_scan:
            if output is None:
                parser.error("unable to infer --output (because --no-scan was given)")
        else:
            parser.error("no SRPM (or tarball) specified on the command line")

    if args.no_scan and args.shell_cmd is not None:
        parser.error("--shell-cmd makes no sense with --no-scan")

    if args.base_srpm is None:
        if args.base_mock_profile is not None:
            parser.error("--base-root makes no sense without --base-srpm")
    else:
        if args.diff_patches:
            parser.error("options --diff-patches and --base-scan are mutually exclusive")

    props = ScanProps()
    props.plugins               = plugins.plug_by_name
    props.cswrap_timeout        = args.cswrap_timeout
    props.keep_going            = args.keep_going
    props.no_scan               = args.no_scan
    props.print_defects         = args.print_defects
    props.use_login_shell       = args.use_login_shell in [True, None]
    props.shell_cmd_to_build    = args.shell_cmd
    props.srpm                  = args.SRPM
    props.base_srpm             = args.base_srpm
    props.skip_mock_init        = args.skip_init
    props.skip_mock_clean       = args.no_clean

    if args.embed_context > 0:
        # we need 'csgrep --embed-context' to work in the chroot for --embed-context
        props.install_opt_pkgs += ["csdiff >= 1.2.1"]

    if args.run_check:
        # run the %check section of specfile
        props.run_check = True

    # parse and append rpm-build opts
    for opt in args.rpm_build_opts:
        props.rpm_opts += shlex.split(opt)

    # initialize the %{_smp_mflags} RPM macro
    mflags_rpmm = "_smp_mflags"
    mflags_rpmm += " -j%d" % args.jobs
    props.rpm_opts += ["--define", mflags_rpmm]

    # make sure that we have a configuration for the selected mock profile
    props.mock_profile = args.mock_profile
    require_file(parser, "/etc/mock/%s.cfg" % props.mock_profile)
    if args.base_mock_profile is None:
        props.base_mock_profile = props.mock_profile
    else:
        props.base_mock_profile = args.base_mock_profile
        require_file(parser, "/etc/mock/%s.cfg" % props.base_mock_profile)

    # append the list of packages to install specified on command-line
    for pkg in args.install:
        props.install_pkgs += pkg.split()

    if not props.no_scan:
        # make sure that 'srpm' is a file (it can be a tar archive instead of SRPM)
        require_file(parser, props.srpm)

    if props.srpm is not None:
        # resolve NVR
        srpm_base = os.path.basename(props.srpm)
        if props.shell_cmd_to_build is None:
            props.nvr = re.sub("\\.src\\.rpm$", "", srpm_base)
        else:
            props.nvr = re.sub("\\.tar$", "", re.sub("\\.[^.]*$", "", srpm_base))

    # resolve name of the file/dir we are going to store the results to
    if args.output is None:
        output = props.nvr + ".tar.xz"
    output = os.path.realpath(output)

    # FIXME: TOCTOU race
    if os.path.exists(output) and not args.force:
        parser.error("'%s' already exists, use --force to proceed" % output)

    # handle --known-false-positives
    if args.known_false_positives:
        require_file(parser, args.known_false_positives)
        filter_cmd = 'csdiff --json-output --show-internal "%s" -' % args.known_false_positives
        props.result_filters += [ filter_cmd ]
    props.known_false_positives = args.known_false_positives

    # poll plug-ins to reflect themselves in ScanProps
    plugins.handle_args(parser, args, props)
    props.any_tool = (plugins.num_enabled() > 0)

    if props.run_check:
        # we need to run %install to be able to run %check
        props.need_rpm_bi = True

    if args.diff_patches:
        ec = do_diff_scan(props, output, args, diff_patches=True)
    elif args.base_srpm is not None:
        ec = do_diff_scan(props, output, args, diff_patches=False)
    else:
        ec = do_scan(props, output, args, args.skip_patches)

    sys.exit(ec)


def do_scan(props, output, args, skip_patches):
    if skip_patches:
        props.rpm_opts += RAWBUILD_RPM_OPTS

    try:
        with ScanResults(output, "csmock", "@VERSION@", props.keep_going) as results:
            results.ini_writer.append("mock-config", props.mock_profile)
            results.ini_writer.append("project-name", props.nvr)
            if props.known_false_positives:
                results.ini_writer.append("known-false-positives", props.known_false_positives)

            if not props.any_tool:
                # no tool enabled
                results.error("No tools are enabled, only trying to build \
the package.  Use --tools or --all-tools to enable them!\n", ec=0)

            # dump list of RPMs installed on the host (for debugging purposes)
            results.exec_cmd(
                "rpm -qa | sort -V > '%s/rpm-list-host.txt'" % results.dbgdir,
                shell=True)

            if not props.no_scan:
                if props.shell_cmd_to_build is None:
                    # check the given SRPM
                    if results.get_cmd_output("rpm -pq '%s'" % props.srpm)[0] != 0:
                        results.fatal_error("failed to open SRPM: %s" % props.srpm)
                    (ec, spec) = results.get_cmd_output(
                        "rpm -lpq '%s' | grep '\\.spec$'" % props.srpm)
                    if ec != 0:
                        results.fatal_error("no specfile found in SRPM: %s" % props.srpm)
                    spec = spec.rstrip()
                    spec_in = "/builddir/build/SPECS/%s" % spec

                # copy the given SRPM into our tmp dir
                srpm_base = os.path.basename(props.srpm)
                srpm_dup = "%s/%s" % (results.tmpdir, srpm_base)
                shutil.copyfile(props.srpm, srpm_dup)
                props.copy_in_files += [srpm_dup]

            # run pre-mock hooks
            for hook in props.pre_mock_hooks:
                rv = hook(results)
                if rv != 0:
                    results.error("pre-mock hook failed", ec=rv)

            with MockWrapper(results, props) as mock:
                supermin_in_use = False
                if not props.no_scan and props.shell_cmd_to_build is None:
                    (ec, _) = results.get_cmd_output("rpm -qp '%s' --requires | grep '^supermin'" % srpm_dup)
                    supermin_in_use = (ec == 0)

                    # first rebuild the given SRPM (some deps might be required even for the rebuild)
                    mock.init_and_install(srpm_dup, force_scrub=supermin_in_use)

                    # install the copied SRPM into the chroot
                    srpm_in = "/builddir/%s" % srpm_base
                    mock.exec_mock_cmd(["--copyin", srpm_dup, srpm_in])
                    mock.exec_chroot_cmd("chown mockbuild -R /builddir")
                    mock.exec_mockbuild_cmd("rpm -Uvh --nodeps '%s'" % srpm_in)

                    # rebuild the given SRPM (and rename to match the original one)
                    cmd_tpl = "rpmbuild -bs --nodeps %s %s && sh -c 'cd \
/builddir/build/SRPMS && eval mv -v *.src.rpm %s || :'"
                    mock.exec_mockbuild_cmd(
                        cmd_tpl % (spec_in, strlist_to_shell_cmd(props.rpm_opts), srpm_base))

                    # use the rebuilt SRPM to get the dependency list
                    mock.copy_out(["/builddir/build/SRPMS/%s" % srpm_base, srpm_dup])

                # run `mock --init`, `mock --installdeps`, and `mock --install`
                mock.init_and_install(srpm_dup, props.install_pkgs, keep_going=props.keep_going)

                # install optional packages (if any)
                if props.install_opt_pkgs:
                    mock.try_install(props.install_opt_pkgs)
                    # just to update rpm-list-mock.txt
                    find_missing_pkgs([], results, mock)

                # remove unwanted packages (if any)
                if props.install_pkgs_blacklist:
                    mock.remove(props.install_pkgs_blacklist)
                    # just to update rpm-list-mock.txt
                    find_missing_pkgs([], results, mock)

                if supermin_in_use:
                    # attempt to make name resolving work in the chroot
                    mock.copy_in_resolv_conf()

                if props.shell_cmd_to_build is not None:
                    # prepare a build script in our tmp dir
                    build_script = "%s/build.sh" % results.tmpdir
                    cmd_tpl = "printf '#!/bin/sh\n\
cd /builddir/build/BUILD || exit $?\n\
cd %%s*/ || cd *\n\
%%s' '%s' '%s' | tee '%s' >&2\n"
                    results.exec_cmd(
                        cmd_tpl % (props.nvr, props.shell_cmd_to_build, build_script),
                        shell=True)
                    props.copy_in_files += [build_script]

                # copy required files into the chroot
                cmd = "tar -cP "
                cmd += strlist_to_shell_cmd(props.copy_in_files)
                cmd += " | "
                cmd += strlist_to_shell_cmd(
                    mock.get_mock_cmd(["--shell", "tar -xC/"]))
                results.exec_cmd(cmd, shell=True)

                # run post-depinst hooks
                for hook in props.post_depinst_hooks:
                    rv = hook(results, mock)
                    if rv != 0:
                        results.error("post-depinst hook failed", ec=rv)

                if not props.no_scan:
                    if props.shell_cmd_to_build is None:
                        # install the copied SRPM into the chroot
                        mock.exec_chroot_cmd("rpm -Uvh --nodeps '%s'" % srpm_dup)
                        # make the installed SRPM accessible (if the maintainer did not)
                        mock.exec_chroot_cmd("chmod -R +r /builddir")

                    if props.keep_going:
                        # include ENABLE_KEEP_GOING_SCRIPT into CHROOT_FIXUPS
                        cmd = "ln -fv '%s' '%s'" % (ENABLE_KEEP_GOING_SCRIPT, CHROOT_FIXUPS)
                        mock.exec_mock_cmd(["--chroot", cmd])

                    # run fixups scripts
                    cmd_tpl = "for i in %s/*; do test -x $i && echo RUN: $i >&2 && $i; done"
                    mock.exec_mock_cmd(["--shell", cmd_tpl % CHROOT_FIXUPS])

                    if props.shell_cmd_to_build is None:
                        # run %prep phase without pluggin-in any static analyzers
                        cmd = "rpmbuild -bp --nodeps %s %s" % (spec_in, strlist_to_shell_cmd(props.rpm_opts))
                        ec = mock.exec_mockbuild_cmd(cmd, quiet=False)
                    else:
                        # extract the given archive (we got instead of SRPM)
                        if re.match("^.*\\.zip$", srpm_dup):
                            # ZIP archive
                            prep_cmd_tpl = "unzip -d '%s' '%s'"
                        else:
                            # assume TAR
                            prep_cmd_tpl = "tar -C '%s' -xvf '%s'"
                        prep_cmd = prep_cmd_tpl % ("/builddir/build/BUILD", srpm_dup)
                        ec = mock.exec_mockbuild_cmd(prep_cmd)

                    if ec != 0:
                        results.error("%prep failed", ec=ec)

                    # make the unpacked contents accessible (if the maintainer did not)
                    mock.exec_chroot_cmd("chmod -R +r /builddir/build")

                    if props.shell_cmd_to_build is None:
                        # run %build phase with static analyzers plugged-in
                        build_cmd = "rpmbuild -bc --nodeps --short-circuit %s %s" \
                                % (spec_in, strlist_to_shell_cmd(props.rpm_opts))
                    else:
                        # run the above prepared build script
                        build_cmd = "sh -x '%s'" % build_script

                    # wrap build_cmd by all the necessary wrappers
                    build_cmd = props.wrap_build_cmd(build_cmd)

                    # initialize environment variables according to ScanProps
                    build_cmd = props.wrap_shell_cmd_by_env(build_cmd)

                    ec = mock.exec_mockbuild_cmd(build_cmd, quiet=False)
                    if ec != 0:
                        results.error("%build failed", ec=ec)

                    if props.need_rpm_bi:
                        rpm_opts = props.rpm_opts
                        if not props.run_check:
                            # disable %check while running 'rpmbuild -bi'
                            if mock.exec_chroot_cmd("rpmbuild --nocheck") == 0:
                                rpm_opts += ["--nocheck"]
                            else:
                                # fragile compatiblity workaround for older versions of rpm-build,
                                # known to break if unescaped %check appears in a change log entry
                                rpm_opts += ["--define", "check\\\n%%check\\\nexit 0"]

                        if props.shell_cmd_to_build is not None:
                            results.fatal_error("SRPM is required by a plug-in")
                        cmd = "rpmbuild -bi --nodeps --short-circuit %s %s" \
                            % (spec_in, strlist_to_shell_cmd(rpm_opts))

                        # wrap %install cmd by all %build cmd wrappers (workaround for buggy pkgs)
                        cmd = props.wrap_build_cmd(cmd)

                        # initialize environment variables according to ScanProps
                        cmd = props.wrap_shell_cmd_by_env(cmd)

                        ec = mock.exec_mockbuild_cmd(cmd, quiet=False)
                        if ec != 0:
                            results.error("%install failed", ec=ec)
                        bd_flt = "sed 's|/builddir/build/BUILDROOT/[^/]*/|/builddir/build/BUILD//|'"
                        props.result_filters = [bd_flt] + props.result_filters

                    # execute post-build commands in the chroot
                    for cmd in props.post_build_chroot_cmds:
                        mock.exec_chroot_cmd(cmd)

                    # get the (intermediate) results out of the chroot
                    if props.copy_out_files:
                        cmd = strlist_to_shell_cmd(
                            mock.get_mock_cmd(
                                ["--shell", "tar -c --remove-files " + strlist_to_shell_cmd(
                                    props.copy_out_files)]))

                        cmd += " | tar -xC '%s'" % results.dbgdir_raw
                        if results.exec_cmd(cmd, shell=True) != 0:
                            results.error("failed to get intermediate results from mock")

                if not props.no_scan:
                    if props.pick_cswrap_results(results) != 0:
                        results.error("failed to pick cswrap results")

                    # run post-process hooks
                    for hook in props.post_process_hooks:
                        rv = hook(results)
                        if rv != 0:
                            results.error("post-process hook failed", ec=rv)

                # we are done with IniWriter
                results.ini_writer.close()

                # merge all results into a single file named scan-results-all.js
                ini_file = "%s/scan.ini" % results.resdir
                js_file = "%s/scan-results.js" % results.resdir
                all_file = "%s/scan-results-all.js" % results.dbgdir
                cmd = "cslinker --quiet --cwelist '%s' --inifile '%s' '%s'/* > '%s'" \
                        % (CWE_MAP_FILE, ini_file, results.dbgdir_uni, all_file)
                results.exec_cmd(cmd, shell=True)

                if args.embed_context > 0:
                    # embed context lines from source program files
                    tmp_file = "%s.tmp" % all_file
                    cmd = strlist_to_shell_cmd(
                        mock.get_mock_cmd(
                            ["--shell", "csgrep --mode=json --embed-context %d" % args.embed_context]))
                    cmd += " < '%s' > '%s'" % (all_file, tmp_file)
                    if results.exec_cmd(cmd, shell=True) == 0:
                        shutil.move(tmp_file, all_file)

            # we are done with mock

            # apply filters, sort the list and store the result as scan-results.js
            cmd = "cat '%s'" % all_file
            for filt in props.result_filters:
                cmd += " | %s" % filt
            cmd += " | cssort --key=path > '%s'" % js_file
            results.exec_cmd(cmd, shell=True)

            finalize_results(js_file, results, props)
            return results.ec

    except FatalError as error:
        return error.ec


def do_diff_scan(props, output, args, diff_patches):
    try:
        with ScanResults(output, "csmock", "@VERSION@", props.keep_going, create_dbgdir=False) as results:
            run0_props = copy.deepcopy(props)
            csdiff = "csdiff"
            if diff_patches:
                # we are looking for defects in patches
                assert not args.skip_patches
                title = "%s - Defects in Patches" % props.nvr
            else:
                # this is a version-diff-build
                run0_props.srpm         = run0_props.base_srpm
                run0_props.mock_profile = run0_props.base_mock_profile
                csdiff += " --ignore-path"
                title = "%s - Defects not detected in %s" % (props.nvr, props.base_srpm)

            run0 = "%s/run0" % results.resdir
            ec = do_scan(run0_props, run0, args, skip_patches=(args.skip_patches or diff_patches))
            if ec != 0:
                results.error("scan of baseline package failed, cannot continue with scan of %s" %
                        props.nvr, ec=ec)

            run1 = "%s/run1" % results.resdir
            ec = do_scan(props, run1, args, skip_patches=args.skip_patches)
            if ec != 0:
                results.error("scan of %s failed" % props.nvr, ec=ec)

            # diff and process fixed defects
            run0_file = "%s/scan-results.js" % run0
            run1_file = "%s/scan-results.js" % run1
            js_file_fixed = "%s/scan-results-fixed.js" % results.resdir
            cmd = "%s --fixed %s %s > %s" % (csdiff, run0_file, run1_file, js_file_fixed)
            if results.exec_cmd(cmd, shell=True) != 0:
                results.error("csdiff --fixed failed")
            transform_results(js_file_fixed, results)

            # finalize scan.ini
            results.ini_writer.append("title", title)
            results.ini_writer.close()
            ini_file = "%s/scan.ini" % results.resdir

            # diff and process added defects
            js_file = "%s/scan-results.js" % results.resdir
            cmd_tpl = "%s %s %s | cslinker --inifile %s - > %s"
            cmd = cmd_tpl % (csdiff, run0_file, run1_file, ini_file, js_file)
            if results.exec_cmd(cmd, shell=True) != 0:
                results.error("csdiff failed")
            finalize_results(js_file, results, props)

            return results.ec

    except FatalError as error:
        return error.ec

if __name__ == '__main__':
    main()
